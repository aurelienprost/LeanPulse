<?xml version="1.0" encoding="UTF-8"?>

<!-- =================================================================

This stylesheet defines named templates and functions for common tasks.

Copyright (c) 2014 LeanPulse. All rights reserved.

Author: AurÃ©lien PROST (a.prost@leanpulse.com)


======================================================================
					!!!! DEVELOPER NOTES !!!!
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

DO NOT EDIT THIS FILE !

This stylesheet implements generic named templates and functions that
can be called in the parent stylesheets. They shoudn't be overridden.

================================================================== -->

<xsl:stylesheet xmlns:fo="http://www.w3.org/1999/XSL/Format"
	xmlns:fox="http://xmlgraphics.apache.org/fop/extensions"
	xmlns:svg="http://www.w3.org/2000/svg"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:fn="http://www.w3.org/2005/xpath-functions"
	xmlns:saxon="http://saxon.sf.net/"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:syd="http://www.leanpulse.com/schemas/syd/2011/core"
	xmlns:w="http://schemas.microsoft.com/office/word/2003/wordml"
	xmlns:wx="http://schemas.microsoft.com/office/word/2003/auxHint"
	xmlns:tex="http://www-sop.inria.fr/miaou/tralics/"
	exclude-result-prefixes="xsl fn saxon xs syd w wx tex"
	extension-element-prefixes="saxon"
	version="2.0">
	
	<!-- Include stylesheet to be able to convert MS Word 2003 XML comments to XSL-FO. -->
	<xsl:include href="wordml/wordml2fo.xsl" />
	
	<!-- Include stylesheet to be able to convert TexML comments to XSL-FO. -->
	<xsl:include href="latexml/latexml2fo.xsl" />
	
	
	<!-- Parameter to indicate if the model dependencies are rendered and how (values are: "false", "true", "embed") -->
	<xsl:param name="gendep" />
	
	<!-- The URI to the directory where input XML files are stored -->
	<xsl:param name="xmluri" />
	
	<!-- Parameter to dynamically resolve links to external documents (for referenced models). -->
	<!-- It must give for each dependency the actual path to the external document. The path should be relative
	if possible. The formatting is the following: "model1=dir1/model1.pdf;model2=dir2/model2.pdf" -->
	<xsl:param name="refmdlpaths" select="''" />
	
	<!-- Defines the root url for DOORS links -->
	<xsl:param name="doorsbaseurl" select="'doors://YOUR_DOORS_BASE_URL-'" />
	
	<!-- Parameter to indicate if backward links should be displayed in the data dictionary. -->
	<xsl:param name="showdatausage" select="'true'" />
	
	
	<!-- For each child node in the input node-set, calls the template with the same name and
	provides the configuration node as a "config" parameter. -->
	<xsl:template name="ExecStructure">
		<xsl:param name="structure"/>
		<xsl:variable name="context" select="."/>
		<xsl:for-each select="$structure/child::node()">
			<xsl:variable name="templateName" select="fn:name()"/>
			<xsl:if test="not($templateName = 'NOP')">
				<!-- Switch context back and pass the config as a param -->
				<xsl:variable name="config" select="."/>
				<xsl:for-each select="$context">
					<saxon:call-template name="{$templateName}">
						<xsl:with-param name="config" select="$config"/>
					</saxon:call-template>
				</xsl:for-each>
			</xsl:if>
		</xsl:for-each>
	</xsl:template>
	
	<!-- Sets title and author in the document metadata of the PDF document. -->
	<xsl:template name="AddDocumentMetaData">
		<xsl:param name="title"/>
		<xsl:param name="author"/>
		<fo:declarations>
			<x:xmpmeta xmlns:x="adobe:ns:meta/">
				<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
					<rdf:Description rdf:about="" xmlns:dc="http://purl.org/dc/elements/1.1/">
						<dc:title><xsl:value-of select="$title"/></dc:title>
						<dc:creator><xsl:value-of select="$author" /></dc:creator>
					</rdf:Description>
				</rdf:RDF>
			</x:xmpmeta>
		</fo:declarations>
	</xsl:template>
	
	<!-- Apply a given style (named template defining attributes) to the parent element. -->
	<xsl:template name="ApplyStyle">
		<xsl:param name="style"/>
		<saxon:call-template name="{$style}"/>
	</xsl:template>
	
	<!-- Adds a title. -->
	<xsl:template name="AddTitle">
		<xsl:param name="config"/>
		<fox:destination internal-destination="{$config/@id}" />
		<fo:block id="{$config/@id}" keep-with-next="always">
			<xsl:if test="$config/@break">
				<xsl:attribute name="break-before" select="$config/@break"/>
			</xsl:if>
			<xsl:if test="$config/@indent">
				<xsl:attribute name="margin-left" select="$config/@indent"/>
			</xsl:if>
			<xsl:if test="$config/@title">
				<saxon:call-template name="{$config/@style}"/>
				<xsl:value-of select="$config/@num"/>
				<xsl:choose>
					<xsl:when test="$config/@sep">
						<xsl:value-of select="$config/@sep"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text> </xsl:text>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:value-of select="$config/@title"/>
			</xsl:if>
		</fo:block>
	</xsl:template>
	
	<!-- Adds a paragraph with some text. -->
	<xsl:template name="AddParagraph">
		<xsl:param name="config"/>
		<fo:block linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="ignore-if-surrounding-linefeed" wrap-option="wrap">
			<xsl:if test="$config/@style">
				<saxon:call-template name="{$config/@style}"/>
			</xsl:if>
			<xsl:value-of select="$config/@text"/>
		</fo:block>
	</xsl:template>
	
	<!-- Adds a comment paragraph retrieved by its ID. -->
	<xsl:template name="AddComment">
		<xsl:param name="config"/>
		<fo:block>
			<xsl:if test="$config/@style">
				<saxon:call-template name="{$config/@style}"/>
			</xsl:if>
			<xsl:variable name="comment" select="syd:getNodeById(fn:root(),$config/@file,$config/@id,'syd:comment')"/>
			<xsl:choose>
				<xsl:when test="not($comment)">No information.</xsl:when>
				<xsl:otherwise>
					<xsl:for-each select="$comment[1]">
						<xsl:choose>
							<xsl:when test="$comment/@type = 'wordml'">
								<xsl:call-template name="AddWordMlComment"/>
							</xsl:when>
							<xsl:when test="$comment/@type = 'latexml'">
								<xsl:call-template name="AddLatexMlComment"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:attribute name="linefeed-treatment">preserve</xsl:attribute>
								<xsl:attribute name="white-space-collapse">false</xsl:attribute>
								<xsl:attribute name="white-space-treatment">ignore-if-surrounding-linefeed</xsl:attribute>
								<xsl:attribute name="wrap-option">wrap</xsl:attribute>
								<xsl:copy-of select="$comment/syd:text/text()" />
							</xsl:otherwise>
						</xsl:choose>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</fo:block>
	</xsl:template>
	
	<!-- Adds a MS Word 2003 XML comment in the XSL-FO document. -->
	<!-- This template extracts the main section from the WordML document
	and calls an imported template to perform its conversion to XSL-FO. -->
	<xsl:template name="AddWordMlComment">
		<!-- Finds the main section in the WordML document. -->
		<xsl:variable name="mlsect" select="fn:current()/w:wordDocument/w:body/wx:sect//wx:sub-section/*[fn:name() != 'wx:sub-section' ] | fn:current()/w:wordDocument/w:body/wx:sect/*[fn:name() != 'wx:sub-section' ] | fn:current()/w:wordDocument/w:body/*[fn:name() != 'wx:sect' ]"/>
		<xsl:if test="$mlsect/descendant::text()"> <!-- Only add block if the comment isn't empty. -->
			<xsl:call-template name="wx:sect"> <!-- Conversion template coming from the imported stylesheet. -->
				<xsl:with-param name="context" select="$mlsect" />
			</xsl:call-template>
		</xsl:if>
	</xsl:template>
	
	<!-- Adds a LaTeX XML comment (converted by tralics) in the XSL-FO document. -->
	<xsl:template name="AddLatexMlComment">
		<xsl:if test="fn:current()/child::tex:std">
			<xsl:apply-templates select="fn:current()/child::tex:std"/>
		</xsl:if>
	</xsl:template>
	
	<!-- Computes the comment structure to enable titles to be defined in the
	comment and taken into account in the global numbering of the document. -->
	<xsl:template name="ComputeCommentStructure">
		<xsl:param name="context" select="fn:current()"/>
		<xsl:choose>
			<xsl:when test="$context/@type = 'wordml'">
				<!-- TODO: implement -->
			</xsl:when>
			<xsl:when test="$context/@type = 'latexml'">
				<xsl:call-template name="texComputeStructure">
					<xsl:with-param name="context" select="$context"/>
				</xsl:call-template>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	
	<!-- Adds a system snapshot (SVG picture) in the XSL-FO document. -->
	<!-- The picture is automatically scaled to fit the page and links to
	external documents (for referenced models) are resolved according to
	the paths provided by the parameter "refmdlpaths". -->
	<xsl:template name="AddSnapshot">
		<xsl:param name="config"/>
		<fo:block>
			<xsl:if test="$config/@style">
				<saxon:call-template name="{$config/@style}"/>
			</xsl:if>
			<xsl:variable name="snapshot" select="syd:getNodeByParentId(fn:root(),$config/@file,$config/@id,'syd:snapshot')"/>
			<fo:instream-foreign-object scaling="uniform">
				<xsl:variable name="snapHeight" select="if (fn:ends-with($snapshot/*/@height,'mm')) then fn:number(fn:substring-before($snapshot/*/@height,'mm')) else fn:number($snapshot/*/@height)"/>
				<xsl:variable name="snapWidth" select="if (fn:ends-with($snapshot/*/@width,'mm')) then fn:number(fn:substring-before($snapshot/*/@width,'mm')) else fn:number($snapshot/*/@width)"/>
				<xsl:choose>
					<xsl:when test="($snapHeight div $snapWidth) &lt; ($config/@maxheight div $config/@maxwidth)">
						<xsl:attribute name="content-width" select="fn:concat($config/@maxwidth,'mm')"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:attribute name="content-height" select="fn:concat($config/@maxheight,'mm')"/>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:apply-templates select="$snapshot/*" mode="copysvg"/>
			</fo:instream-foreign-object>
		</fo:block>
	</xsl:template>
	
	<!-- Key to find the corresponding file for a given path of a model reference subsystem. -->
	<xsl:key name="mdlrefs" match="//syd:modelref" use="@id" />
	
	<!-- Copy SVG links and replace the destination for external documents. -->
	<xsl:template match="svg:a" mode="copysvg">
		<xsl:element name="svg:a">
			<xsl:attribute name="xlink:href">
				<xsl:variable name="mdlref" select="fn:key('mdlrefs',fn:substring(@xlink:href,2))"/>
				<xsl:choose>
					<xsl:when test="fn:exists($mdlref)">
						<xsl:choose>
							<xsl:when test="$gendep='embed'">
								<xsl:value-of select="fn:concat('#', if(fn:exists($mdlref/@system)) then $mdlref/@system else $mdlref/@file)"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:variable name="refmdlpath" select="syd:get-map-value($refmdlpaths, $mdlref/@file)"/>
								<xsl:choose>
									<xsl:when test="fn:string-length($refmdlpath) > 0">
										<xsl:variable name="refdest" select="if(fn:exists($mdlref/@system)) then $mdlref/@system else $mdlref/@file"/>
										<xsl:value-of select="fn:concat($refmdlpath,'#dest=',$refdest)"/>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="@xlink:href"/>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="@xlink:href"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
			<xsl:copy-of select="node()" />
		</xsl:element>
	</xsl:template>
	
	<!-- Other elements in SVGs are directly copied. -->
	<xsl:template match="@*|node()" mode="copysvg">
		<xsl:copy>
			<xsl:apply-templates select="@*|node()" mode="copysvg"/>
		</xsl:copy>
	</xsl:template>
	
	<!-- Adds the Page Masters for all the snapshots where Tiled Printing is enabled. -->
	<xsl:template name="AddTilePageMasters">
		<xsl:for-each-group select="//syd:snapshot[@pagewidth and @pageheight]" group-by="fn:concat(@pagewidth,'-',@pageheight,'-',@pagemargins,'-',@units)">
			<xsl:variable name="margins" select="fn:tokenize(@pagemargins,'\s+')"/>
			<fo:simple-page-master master-name="{fn:concat(@pagewidth,'-',@pageheight,'-',@pagemargins,'-',@units)}"
					page-width="{fn:concat(@pagewidth,@units)}" page-height="{fn:concat(@pageheight,@units)}"
					margin-left="{fn:concat($margins[1],@units)}" margin-top="{fn:concat($margins[2],@units)}"
					margin-right="{fn:concat($margins[3],@units)}" margin-bottom="{fn:concat($margins[4],@units)}">
				<fo:region-body />
			</fo:simple-page-master>
		</xsl:for-each-group>
	</xsl:template>
	
	<!-- Prints all the tiled snapshots. -->
	<xsl:template name="PrintTileSnapshots">
		<xsl:for-each select="//syd:snapshot[@pagewidth and @pageheight]">
			<fo:page-sequence master-reference="{fn:concat(@pagewidth,'-',@pageheight,'-',@pagemargins,'-',@units)}">
				<fo:flow flow-name="xsl-region-body">
					<xsl:variable name="snap">
						<xsl:apply-templates select="./*" mode="copysvg"/>
					</xsl:variable>
					<xsl:variable name="tilewidth" select="@tilewidth"/>
					<xsl:variable name="tileheight" select="@tileheight"/>
					<xsl:variable name="viewbox" select="fn:tokenize($snap/svg:svg/@viewBox,'\s+')"/>
					<xsl:for-each select="1 to xs:integer(fn:ceiling(fn:number($viewbox[4]) div $tileheight))">
						<xsl:variable name="row" select="fn:position()"/>
						<xsl:for-each select="1 to xs:integer(fn:ceiling(fn:number($viewbox[3]) div $tilewidth))">
							<xsl:variable name="column" select="fn:position()"/>
							<fo:block break-before="page">
								<fo:instream-foreign-object width="100%" height="100%" content-width="scale-to-fit" content-height="scale-to-fit">
									<svg:svg viewbox="0 0 {$tilewidth} {$tileheight}" width="{$tilewidth}" height="{$tileheight}">
										<svg:g transform="translate(-{$tilewidth * ($column - 1)},-{$tileheight * ($row - 1)})">
											<xsl:copy-of select="$snap/svg:svg/*"/>
										</svg:g>
									</svg:svg>
								</fo:instream-foreign-object>
							</fo:block>
						</xsl:for-each>
					</xsl:for-each>
				</fo:flow>
			</fo:page-sequence>
		</xsl:for-each>
	</xsl:template>
	
	<!-- Adds a small paragraph to link the referenced model. -->
	<xsl:template name="AddModelReference">
		<xsl:param name="config"/>
		<fo:block>
			<xsl:if test="$config/@style">
				<saxon:call-template name="{$config/@style}"/>
			</xsl:if>
			<xsl:variable name="modelref" select="syd:getNodeById(fn:root(),$config/@file,$config/@id,'syd:modelref')"/>
			<xsl:variable name="pdf" select="syd:get-map-value($refmdlpaths, $modelref/@file)"/>
			<xsl:choose>
				<xsl:when test="fn:exists($modelref/@system)">
					<xsl:text>Reference subsystem: </xsl:text>
					<fo:basic-link external-destination="{fn:concat($pdf,'#dest=',$modelref/@system)}" color="#000066">
						<xsl:value-of select="$modelref/@system"/>
					</fo:basic-link>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>Reference model: </xsl:text>
					<fo:basic-link external-destination="{fn:concat($pdf,'#dest=',$modelref/@file)}" color="#000066">
						<xsl:value-of select="$modelref/@file"/>
					</fo:basic-link>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="fn:string-length($pdf) = 0">
				<xsl:text> (not found !!)</xsl:text>
			</xsl:if>
			<xsl:text>.</xsl:text>
		</fo:block>
	</xsl:template>
	
	<!-- Adds a truthtable in the XSL-FO document. -->
	<xsl:template name="AddTruthTable">
		<xsl:param name="config"/>
		<fo:block>
			<xsl:if test="$config/@style">
				<saxon:call-template name="{$config/@style}"/>
			</xsl:if>
			<xsl:variable name="truthtable" select="syd:getNodeById(fn:root(),$config/@file,$config/@id,'syd:truthtable')"/>
			<fo:table border="1pt solid #000000" table-layout="fixed" width="100%">
				<fo:table-column column-width="10%" />
				<xsl:for-each select="$truthtable/syd:condition[1]/syd:col">
					<xsl:choose>
						<xsl:when test="fn:position() &lt;= 2">
							<fo:table-column>
								<xsl:attribute name="column-width" select="fn:concat(6 * 90 div (last() + 10),'%')"/>
							</fo:table-column>
						</xsl:when>
						<xsl:otherwise>
							<fo:table-column>
								<xsl:attribute name="column-width" select="fn:concat(90 div (last() + 10),'%')"/>
							</fo:table-column>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
				<fo:table-header font-weight="bold">
					<fo:table-row border="1pt solid #000000">
						<fo:table-cell>
							<xsl:attribute name="number-columns-spanned" select="fn:count($truthtable/syd:condition[1]/syd:col) + 1" />
							<fo:block margin="3.5pt">Condition Table</fo:block>
						</fo:table-cell>
					</fo:table-row>
					<fo:table-row border-bottom="0.5pt solid #000000" text-align="center">
						<fo:table-cell border-right="0.5pt solid #000000">
							<fo:block/>
						</fo:table-cell>
						<xsl:for-each select="$truthtable/syd:condition[1]/syd:col">
							<fo:table-cell>
								<xsl:if test="fn:position() &lt; last()">
									<xsl:attribute name="border-right">0.5pt solid #000000</xsl:attribute>
								</xsl:if>
								<fo:block margin="3.5pt">
									<xsl:choose>
										<xsl:when test="fn:position() = 1">Description</xsl:when>
										<xsl:when test="fn:position() = 2">Condition</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="fn:concat('D',position() - 2)"/>
										</xsl:otherwise>
									</xsl:choose>
								</fo:block>
							</fo:table-cell>
						</xsl:for-each>
					</fo:table-row>
				</fo:table-header>
				<fo:table-body>
					<xsl:for-each select="$truthtable/syd:condition">
						<fo:table-row border="0.5pt solid #000000">
							<fo:table-cell border-right="0.5pt solid #000000">
								<xsl:choose>
									<xsl:when test="fn:position() &lt; last()">
										<fo:block margin="3.5pt" font-weight="bold" text-align="center"><xsl:value-of select="fn:position()"/></fo:block>
									</xsl:when>
									<xsl:otherwise>
										<fo:block/>
									</xsl:otherwise>
								</xsl:choose>
							</fo:table-cell>
							<xsl:for-each select="syd:col">
								<fo:table-cell>
									<xsl:if test="fn:position() &lt; last()">
										<xsl:attribute name="border-right">0.5pt solid #000000</xsl:attribute>
									</xsl:if>
									<xsl:if test="fn:position() &gt; 2">
										<xsl:attribute name="text-align">center</xsl:attribute>
									</xsl:if>
									<fo:block margin="3.5pt" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="ignore-if-surrounding-linefeed" wrap-option="wrap">
										<xsl:copy-of select="text()" />
									</fo:block>
								</fo:table-cell>
							</xsl:for-each>
						</fo:table-row>
					</xsl:for-each>
				</fo:table-body>
			</fo:table>
			<fo:table border="1pt solid #000000" table-layout="fixed" width="100%">
				<fo:table-column column-width="10%" />
				<xsl:for-each select="$truthtable/syd:action[1]/syd:col">
					<fo:table-column>
						<xsl:attribute name="column-width" select="fn:concat(90 div last(),'%')"/>
					</fo:table-column>
				</xsl:for-each>
				<fo:table-header font-weight="bold">
					<fo:table-row border="1pt solid #000000">
						<fo:table-cell>
							<xsl:attribute name="number-columns-spanned" select="fn:count($truthtable/syd:action[1]/syd:col) + 1" />
							<fo:block margin="3.5pt">Action Table</fo:block>
						</fo:table-cell>
					</fo:table-row>
					<fo:table-row border-bottom="0.5pt solid #000000" text-align="center">
						<fo:table-cell border-right="0.5pt solid #000000">
							<fo:block margin="3.5pt">#</fo:block>
						</fo:table-cell>
						<xsl:for-each select="$truthtable/syd:action[1]/syd:col">
							<fo:table-cell>
								<xsl:if test="fn:position() &lt; last()">
									<xsl:attribute name="border-right">0.5pt solid #000000</xsl:attribute>
								</xsl:if>
								<fo:block margin="3.5pt">
									<xsl:choose>
										<xsl:when test="fn:position() = 1">Description</xsl:when>
										<xsl:when test="fn:position() = 2">Action</xsl:when>
									</xsl:choose>
								</fo:block>
							</fo:table-cell>
						</xsl:for-each>
					</fo:table-row>
				</fo:table-header>
				<fo:table-body>
					<xsl:for-each select="$truthtable/syd:action">
						<fo:table-row border="0.5pt solid #000000">
							<fo:table-cell border-right="0.5pt solid #000000">
								<fo:block margin="3.5pt" font-weight="bold" text-align="center"><xsl:value-of select="fn:position()"/></fo:block>
							</fo:table-cell>
							<xsl:for-each select="syd:col">
								<fo:table-cell>
									<xsl:if test="fn:position() &lt; last()">
										<xsl:attribute name="border-right">0.5pt solid #000000</xsl:attribute>
									</xsl:if>
									<fo:block margin="3.5pt" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="ignore-if-surrounding-linefeed" wrap-option="wrap">
										<xsl:copy-of select="text()" />
									</fo:block>
								</fo:table-cell>
							</xsl:for-each>
						</fo:table-row>
					</xsl:for-each>
				</fo:table-body>
			</fo:table>
		</fo:block>
	</xsl:template>
	
	<!-- Adds an M-function in the XSL-FO document. -->
	<xsl:template name="AddMFunction">
		<xsl:param name="config"/>
		<fo:block linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" wrap-option="wrap">
			<xsl:if test="$config/@style">
				<saxon:call-template name="{$config/@style}"/>
			</xsl:if>
			<xsl:copy-of select="syd:getNodeById(fn:root(),$config/@file,$config/@id,'syd:mfunction')/syd:script/text()" />
		</fo:block>
	</xsl:template>
	
	<!-- Adds a State Transition Matrix in the XSL-FO document. -->
	<xsl:template name="AddTransitionMatrix">
		<xsl:param name="config"/>
		<fo:block>
			<xsl:if test="$config/@style">
				<saxon:call-template name="{$config/@style}"/>
			</xsl:if>
			<xsl:variable name="transitionmatrix" select="syd:getNodeById(fn:root(),$config/@file,$config/@id,'syd:transitionmatrix')"/>
			<xsl:variable name="numconds" select="fn:count($transitionmatrix/syd:conditions/syd:condition)"/>
			<fo:table border="1pt solid #000000" table-layout="fixed" width="100%">
				<fo:table-column column-width="5%" />
				<fo:table-column column-width="5%" />
				<fo:table-column column-width="{fn:concat(90 div ($numconds+1),'%')}" />
				<xsl:for-each select="$transitionmatrix/syd:conditions/syd:condition">
					<fo:table-column column-width="{fn:concat(90 div ($numconds+1),'%')}" />
				</xsl:for-each>
				<fo:table-header>
					<fo:table-row border="1pt solid #000000">
						<fo:table-cell>
							<xsl:attribute name="number-columns-spanned" select="$numconds + 3" />
							<fo:block margin="3.5pt" font-weight="bold"><xsl:value-of select="syd:substring-after-last($transitionmatrix/@id,'/')"/></fo:block>
						</fo:table-cell>
					</fo:table-row>
					<fo:table-row border-bottom="0.5pt solid #000000">
						<fo:table-cell number-columns-spanned="3" border-right="0.5pt solid #000000">
							<fo:block/>
						</fo:table-cell>
						<xsl:for-each select="$transitionmatrix/syd:conditions/syd:condition">
							<fo:table-cell>
								<xsl:if test="fn:position() &lt; last()">
									<xsl:attribute name="border-right">0.5pt solid #000000</xsl:attribute>
								</xsl:if>
								<fo:block margin="3.5pt" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="ignore-if-surrounding-linefeed" wrap-option="wrap">
									<xsl:copy-of select="text()"/>
								</fo:block>
							</fo:table-cell>
						</xsl:for-each>
					</fo:table-row>
				</fo:table-header>
				<fo:table-body display-align="center">
					<xsl:for-each select="$transitionmatrix/syd:cell">
						<fo:table-row border="0.5pt solid #000000">
							<fo:table-cell border-right="0.5pt solid #000000">
								<fo:block margin="1pt" text-align="center">
									<xsl:if test="@default='1'">
										<fo:instream-foreign-object scaling="uniform" content-width="25px">
											<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 30">
												<defs>
													<marker id='tail' markerWidth='4' markerHeight='4' refX='2' refY='2'>
														<circle cx="2" cy="2" r="1" stroke="black" fill="black" />
													</marker>
													<marker id='head' orient="auto" markerWidth='3' markerHeight='6' refX='0.1' refY='3'>
														<path d='M0,0 V6 L3,3 Z' fill="black" />
													</marker>
												</defs>
												<path marker-start='url(#tail)' marker-end='url(#head)' stroke-width='2' fill='none'
													stroke='black' d='M4,4 C4,15 4,20 19,24' />
											</svg>
										</fo:instream-foreign-object>
									</xsl:if>
								</fo:block>
							</fo:table-cell>
							<fo:table-cell border-right="0.5pt solid #000000">
								<fo:block margin="3.5pt" text-align="center"><xsl:value-of select="fn:position()"/></fo:block>
							</fo:table-cell>
							<fo:table-cell border-right="0.5pt solid #000000">
								<fo:block margin="3.5pt" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="ignore-if-surrounding-linefeed" wrap-option="wrap">
									<xsl:value-of select="if(@type='default') then 'DEFAULT' else ( if(@type='inner') then fn:concat(syd:label/text(),'&#xA;&#xA;INNER') else syd:label/text() )"/>
								</fo:block>
							</fo:table-cell>
							<xsl:for-each select="syd:action">
								<fo:table-cell>
									<xsl:if test="fn:position() &lt; last()">
										<xsl:attribute name="border-right">0.5pt solid #000000</xsl:attribute>
									</xsl:if>
									<xsl:if test="text()">
										<fo:block margin="3.5pt" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="ignore-if-surrounding-linefeed" wrap-option="wrap">
											<xsl:copy-of select="text()"/>
										</fo:block>
									</xsl:if>
									<fo:block margin="3.5pt"><xsl:value-of select="@dest"/></fo:block>
								</fo:table-cell>
							</xsl:for-each>
						</fo:table-row>
					</xsl:for-each>
				</fo:table-body>
			</fo:table>
		</fo:block>
	</xsl:template>
	
	<!-- Global variable holding the bus definitions as used in the entire tree of document(s). -->
	<xsl:variable name="globalbustree">
		<xsl:for-each select="/syd:model | /syd:system">
			<xsl:sequence select="syd:extractFromSystemHierarchy(.,'syd:buses')"/>
		</xsl:for-each>
	</xsl:variable>
	
	<!-- Adds the table of bus signals usage for the given subsystem ID. -->
	<xsl:template name="AddBusSignalsUsage">
		<xsl:param name="config"/>
		<xsl:variable name="system" select="$globalbustree//syd:system[@id = $config/@id]"/>
		<xsl:variable name="createdherebusids" select="$system/syd:buses/syd:bus/@out"/>
		<xsl:variable name="createdbelowbusids" select="$system/syd:system/descendant::syd:bus/@out"/>
		<xsl:variable name="todisplaybuses">
			<xsl:sequence select="$globalbustree//syd:bus[@in = $createdherebusids]"/>
			<xsl:sequence select="$globalbustree//syd:bus[@in = $createdbelowbusids and not(fn:exists(ancestor::syd:system[@id = $system/@id]))]"/>
			<xsl:sequence select="$system/descendant::syd:bus[@in and not(@in = $createdbelowbusids)]"/>
		</xsl:variable>
		<xsl:if test="fn:exists($todisplaybuses/syd:bus)">
			<fo:block>
				<xsl:if test="$config/@style">
					<saxon:call-template name="{$config/@style}"/>
				</xsl:if>
				<fo:table border="1pt solid #000000" table-layout="fixed" width="100%" font-size="{$dico-font-size-prop}">
					<fo:table-column column-width="25%" />
					<fo:table-column column-width="75%" />
					<fo:table-header font-weight="bold">
						<fo:table-row border-bottom="1pt solid #000000" >
							<fo:table-cell border-right="0.5pt solid #000000">
								<fo:block margin="3.5pt">Bus Name</fo:block>
							</fo:table-cell>
							<fo:table-cell>
								<fo:block margin="3.5pt">Actually Used Signals</fo:block>
							</fo:table-cell>
						</fo:table-row>
					</fo:table-header>
					<fo:table-body>
						<xsl:for-each-group select="$todisplaybuses/syd:bus" group-by="@in">
							<fo:table-row border-bottom="0.5pt solid #000000" keep-together="always">
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">
										<fo:basic-link internal-destination="{current-grouping-key()}">
											<xsl:value-of select="current-grouping-key()" />
										</fo:basic-link>
									</fo:block>
								</fo:table-cell>
								<fo:table-cell>
									<fo:block margin="3.5pt">
										<xsl:for-each-group select="current-group()/syd:signal" group-by="@name">
											<xsl:if test="fn:position() > 1">
												<xsl:text> | </xsl:text>
											</xsl:if>
											<xsl:for-each select="fn:tokenize(current-grouping-key(), '\.')">
												<xsl:if test="fn:position() > 1">
													<xsl:text>.</xsl:text>
												</xsl:if>
												<fo:basic-link internal-destination="{.}">
													<xsl:value-of select="." />
												</fo:basic-link>
											</xsl:for-each>
										</xsl:for-each-group>
									</fo:block>
								</fo:table-cell>
							</fo:table-row>
						</xsl:for-each-group>
					</fo:table-body>
				</fo:table>
			</fo:block>
		</xsl:if>
	</xsl:template>
	
	<!-- Adds a table of Signals in the XSL-FO document. -->
	<xsl:template name="AddSignalsTable">
		<xsl:param name="config"/>
		<fo:block>
			<xsl:if test="$config/@style">
				<saxon:call-template name="{$config/@style}"/>
			</xsl:if>
			<xsl:variable name="signalset">
				<saxon:call-template name="{$config/@tpname}"/>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="fn:count($signalset/syd:signal) > 0">
					<fo:table border="1pt solid #000000" table-layout="fixed" width="100%" font-size="{$dico-font-size-prop}">
						<fo:table-column column-width="25%" />
						<fo:table-column column-width="15%" />
						<fo:table-column column-width="15%" />
						<fo:table-column column-width="15%" />
						<fo:table-column column-width="5%" />
						<fo:table-column column-width="5%" />
						<fo:table-column column-width="20%" />
						<fo:table-header font-weight="bold">
							<fo:table-row border-bottom="0.5pt solid #000000" >
								<fo:table-cell number-rows-spanned="{if($showdatausage='true') then 3 else 2}" border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Name</fo:block>
								</fo:table-cell>
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Data Type</fo:block>
								</fo:table-cell>
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Min</fo:block>
								</fo:table-cell>
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Max</fo:block>
								</fo:table-cell>
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Units</fo:block>
								</fo:table-cell>
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Dim</fo:block>
								</fo:table-cell>
								<fo:table-cell>
									<fo:block margin="3.5pt">Init Value</fo:block>
								</fo:table-cell>
							</fo:table-row>
							<fo:table-row border-bottom="{if($showdatausage='true') then '0.5' else '1'}pt solid #000000" >
								<fo:table-cell number-columns-spanned="6">
									<fo:block margin="3.5pt">Description</fo:block>
								</fo:table-cell>
							</fo:table-row>
							<xsl:if test="$showdatausage='true'">
								<fo:table-row border-bottom="1pt solid #000000" >
									<fo:table-cell number-columns-spanned="6">
										<fo:block margin="3.5pt">Data Usage</fo:block>
									</fo:table-cell>
								</fo:table-row>
							</xsl:if>
						</fo:table-header>
						<fo:table-body>
							<xsl:variable name="root" select="fn:root()" />
							<xsl:for-each-group select="$signalset/syd:signal" group-by="@name">
								<xsl:sort select="@name"/>
								<fo:table-row border-bottom="0.5pt solid #000000" keep-together="always">
									<fo:table-cell number-rows-spanned="{if($showdatausage='true') then 3 else 2}" border-right="0.5pt solid #000000">
										<fox:destination internal-destination="{@name}"/>
										<fo:block id="{@name}">
							                <fo:block margin="3.5pt">
							                	<xsl:value-of select="fn:replace(@name,'_','_&#x200B;')" />
							                </fo:block>
										</fo:block>
									</fo:table-cell>
									<fo:table-cell border-right="0.5pt solid #000000">
										<fo:block margin="3.5pt"><xsl:value-of select="@dtype" /></fo:block>
									</fo:table-cell>
									<fo:table-cell border-right="0.5pt solid #000000">
										<fo:block margin="3.5pt"><xsl:value-of select="@min" /></fo:block>
									</fo:table-cell>
									<fo:table-cell border-right="0.5pt solid #000000">
										<fo:block margin="3.5pt"><xsl:value-of select="@max" /></fo:block>
									</fo:table-cell>
									<fo:table-cell border-right="0.5pt solid #000000">
										<fo:block margin="3.5pt"><xsl:value-of select="@units" /></fo:block>
									</fo:table-cell>
									<fo:table-cell border-right="0.5pt solid #000000">
										<fo:block margin="3.5pt"><xsl:value-of select="@dim" /></fo:block>
									</fo:table-cell>
									<fo:table-cell>
										<fo:block margin="3.5pt"><xsl:value-of select="fn:replace(fn:replace(@initval,',',',&#x200B;'),';',';&#x200B;')" /></fo:block>
									</fo:table-cell>
								</fo:table-row>
								<fo:table-row border-bottom="0.5pt solid #000000" keep-together="always" keep-with-previous="always">						
									<fo:table-cell number-columns-spanned="6">
										<fo:block margin="3.5pt"><xsl:value-of select="text()" /></fo:block>
									</fo:table-cell>
								</fo:table-row>
								<xsl:if test="$showdatausage='true'">
									<fo:table-row border-bottom="0.5pt solid #000000" keep-with-previous="always">						
										<fo:table-cell number-columns-spanned="6">
											<fo:block margin="3.5pt">
												<xsl:variable name="usage" select="syd:getDataUsage($root,@name)"/>
												<xsl:for-each select="$usage/usedby">
													<fo:block>
														<fo:basic-link internal-destination="{@id}" color="#000066">
															<xsl:value-of select="@id" />
														</fo:basic-link>
													</fo:block>
												</xsl:for-each>
											</fo:block>
										</fo:table-cell>
									</fo:table-row>
								</xsl:if>
							</xsl:for-each-group>
						</fo:table-body>
					</fo:table>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$config/@emptydes"/>
				</xsl:otherwise>
			</xsl:choose>
		</fo:block>
	</xsl:template>
	
	<!-- Adds a table of Parameters in the XSL-FO document. -->
	<xsl:template name="AddParametersTable">
		<xsl:param name="config"/>
		<fo:block>
			<xsl:if test="$config/@style">
				<saxon:call-template name="{$config/@style}"/>
			</xsl:if>
			<xsl:variable name="parameterset">
				<saxon:call-template name="{$config/@tpname}"/>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="fn:count($parameterset/syd:parameter) > 0">
					<fo:table border="1pt solid #000000" table-layout="fixed" width="100%" font-size="{$dico-font-size-prop}">
						<fo:table-column column-width="25%" />
						<fo:table-column column-width="15%" />
						<fo:table-column column-width="15%" />
						<fo:table-column column-width="15%" />
						<fo:table-column column-width="5%" />
						<fo:table-column column-width="25%" />
						<fo:table-header font-weight="bold">
							<fo:table-row border-bottom="0.5pt solid #000000" >
								<fo:table-cell number-rows-spanned="{if($showdatausage='true') then 4 else 3}" border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Name</fo:block>
								</fo:table-cell>
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Data Type</fo:block>
								</fo:table-cell>
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Min</fo:block>
								</fo:table-cell>
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Max</fo:block>
								</fo:table-cell>
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Units</fo:block>
								</fo:table-cell>
								<fo:table-cell>
									<fo:block margin="3.5pt">Dim</fo:block>
								</fo:table-cell>
							</fo:table-row>
							<fo:table-row border-bottom="0.5pt solid #000000" >
								<fo:table-cell number-columns-spanned="5">
									<fo:block margin="3.5pt">Value</fo:block>
								</fo:table-cell>
							</fo:table-row>
							<fo:table-row border-bottom="{if($showdatausage='true') then '0.5' else '1'}pt solid #000000" >
								<fo:table-cell number-columns-spanned="5">
									<fo:block margin="3.5pt">Description</fo:block>
								</fo:table-cell>
							</fo:table-row>
							<xsl:if test="$showdatausage='true'">
								<fo:table-row border-bottom="1pt solid #000000" >
									<fo:table-cell number-columns-spanned="5">
										<fo:block margin="3.5pt">Data Usage</fo:block>
									</fo:table-cell>
								</fo:table-row>
							</xsl:if>
						</fo:table-header>
						<fo:table-body>
							<xsl:variable name="root" select="fn:root()" />
							<xsl:for-each-group select="$parameterset/syd:parameter" group-by="@name">
								<xsl:sort select="@name"/>
								<fo:table-row border-bottom="0.5pt solid #000000" keep-together="always">
									<fo:table-cell number-rows-spanned="{if($showdatausage='true') then 4 else 3}" border-right="0.5pt solid #000000">
										<fox:destination internal-destination="{@name}"/>
										<fo:block id="{@name}">
							                <fo:block margin="3.5pt">
							                	<xsl:value-of select="fn:replace(@name,'_','_&#x200B;')" />
							                </fo:block>
										</fo:block>
									</fo:table-cell>
									<fo:table-cell border-right="0.5pt solid #000000">
										<fo:block margin="3.5pt"><xsl:value-of select="@dtype" /></fo:block>
									</fo:table-cell>
									<fo:table-cell border-right="0.5pt solid #000000">
										<fo:block margin="3.5pt"><xsl:value-of select="@min" /></fo:block>
									</fo:table-cell>
									<fo:table-cell border-right="0.5pt solid #000000">
										<fo:block margin="3.5pt"><xsl:value-of select="@max" /></fo:block>
									</fo:table-cell>
									<fo:table-cell border-right="0.5pt solid #000000">
										<fo:block margin="3.5pt"><xsl:value-of select="@units" /></fo:block>
									</fo:table-cell>
									<fo:table-cell>
										<fo:block margin="3.5pt"><xsl:value-of select="@dim" /></fo:block>
									</fo:table-cell>
								</fo:table-row>
								<fo:table-row border-bottom="0.5pt solid #000000" keep-together="always" keep-with-previous="always">						
									<fo:table-cell number-columns-spanned="5" >
										<fo:block margin="3.5pt"><xsl:value-of select="fn:replace(fn:replace(@value,',',',&#x200B;'),';',';&#x200B;')" /></fo:block>
									</fo:table-cell>
								</fo:table-row>
								<fo:table-row border-bottom="0.5pt solid #000000" keep-together="always" keep-with-previous="always">						
									<fo:table-cell number-columns-spanned="5" >
										<fo:block margin="3.5pt"><xsl:value-of select="text()" /></fo:block>
									</fo:table-cell>
								</fo:table-row>
								<xsl:if test="$showdatausage='true'">
									<fo:table-row border-bottom="0.5pt solid #000000" keep-with-previous="always">
										<fo:table-cell number-columns-spanned="5">
											<fo:block margin="3.5pt">
												<xsl:variable name="usage" select="syd:getDataUsage($root,@name)"/>
												<xsl:for-each select="$usage/usedby">
													<fo:block>
														<fo:basic-link internal-destination="{@id}" color="#000066">
															<xsl:value-of select="@id" />
														</fo:basic-link>
													</fo:block>
												</xsl:for-each>
											</fo:block>
										</fo:table-cell>
									</fo:table-row>
								</xsl:if>
							</xsl:for-each-group>
						</fo:table-body>
					</fo:table>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$config/@emptydes"/>
				</xsl:otherwise>
			</xsl:choose>
		</fo:block>
	</xsl:template>
	
	<!-- Adds a table of 1D Lookups in the XSL-FO document. -->
	<xsl:template name="Add1DLookupsTable">
		<xsl:param name="config"/>
		<fo:block>
			<xsl:if test="$config/@style">
				<saxon:call-template name="{$config/@style}"/>
			</xsl:if>
			<xsl:variable name="lookupset">
				<saxon:call-template name="{$config/@tpname}"/>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="fn:count($lookupset/syd:lookup) > 0">
					<fo:table border="1pt solid #000000" table-layout="fixed" width="100%" font-size="{$dico-font-size-prop}">
						<fo:table-column column-width="30%" />
						<fo:table-column column-width="30%" />
						<fo:table-column column-width="40%" />
						<fo:table-header font-weight="bold">
							<fo:table-row border-bottom="1pt solid #000000" >
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Table</fo:block>
								</fo:table-cell>
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">X Axis</fo:block>
								</fo:table-cell>
								<fo:table-cell>
									<fo:block margin="3.5pt">X Input</fo:block>
								</fo:table-cell>
							</fo:table-row>
						</fo:table-header>
						<fo:table-body>
							<xsl:for-each-group select="$lookupset/syd:lookup" group-by="@table">
								<xsl:sort select="@table"/>
								<fo:table-row border-bottom="0.5pt solid #000000" keep-together="always">
									<fo:table-cell border-right="0.5pt solid #000000">
										<fo:block margin="3.5pt">
											<xsl:if test="fn:string-length(@table) > 0">
												<fo:basic-link internal-destination="{@table}" color="#000066">
													<xsl:value-of select="fn:replace(@table,'_','_&#x200B;')" />
												</fo:basic-link>
											</xsl:if>
										</fo:block>
									</fo:table-cell>
									<fo:table-cell border-right="0.5pt solid #000000">
										<fo:block margin="3.5pt">
											<xsl:if test="fn:string-length(@xaxis) > 0">
												<fo:basic-link internal-destination="{@xaxis}" color="#000066">
													<xsl:value-of select="fn:replace(@xaxis,'_','_&#x200B;')" />
												</fo:basic-link>
											</xsl:if>
										</fo:block>
									</fo:table-cell>
									<fo:table-cell>
										<fo:block margin="3.5pt">
											<xsl:if test="fn:string-length(@xsignal) > 0">
												<fo:basic-link internal-destination="{@xsignal}" color="#000066">
													<xsl:value-of select="fn:replace(@xsignal,'_','_&#x200B;')" />
												</fo:basic-link>
											</xsl:if>
										</fo:block>
									</fo:table-cell>
								</fo:table-row>
							</xsl:for-each-group>
						</fo:table-body>
					</fo:table>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$config/@emptydes"/>
				</xsl:otherwise>
			</xsl:choose>
		</fo:block>
	</xsl:template>
	
	<!-- Adds a table of 2D Lookups in the XSL-FO document. -->
	<xsl:template name="Add2DLookupsTable">
		<xsl:param name="config"/>
		<fo:block>
			<xsl:if test="$config/@style">
				<saxon:call-template name="{$config/@style}"/>
			</xsl:if>
			<xsl:variable name="lookupset">
				<saxon:call-template name="{$config/@tpname}"/>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="fn:count($lookupset/syd:lookup) > 0">
					<fo:table border="1pt solid #000000" table-layout="fixed" width="100%" font-size="{$dico-font-size-prop}">
						<fo:table-column column-width="30%" />
						<fo:table-column column-width="30%" />
						<fo:table-column column-width="40%" />
						<fo:table-header font-weight="bold">
							<fo:table-row border-bottom="0.5pt solid #000000" >
								<fo:table-cell number-rows-spanned="2" border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Table</fo:block>
								</fo:table-cell>
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">X Axis</fo:block>
								</fo:table-cell>
								<fo:table-cell>
									<fo:block margin="3.5pt">X Input</fo:block>
								</fo:table-cell>
							</fo:table-row>
							<fo:table-row border-bottom="1pt solid #000000" >
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Y Axis</fo:block>
								</fo:table-cell>
								<fo:table-cell>
									<fo:block margin="3.5pt">Y Input</fo:block>
								</fo:table-cell>
							</fo:table-row>
						</fo:table-header>
						<fo:table-body>
							<xsl:for-each-group select="$lookupset/syd:lookup" group-by="@table">
								<xsl:sort select="@table"/>
								<fo:table-row border-bottom="0.5pt solid #000000" keep-together="always">
									<fo:table-cell number-rows-spanned="2" border-right="0.5pt solid #000000">
										<fo:block margin="3.5pt">
											<xsl:if test="fn:string-length(@table) > 0">
												<fo:basic-link internal-destination="{@table}" color="#000066">
													<xsl:value-of select="fn:replace(@table,'_','_&#x200B;')" />
												</fo:basic-link>
											</xsl:if>
										</fo:block>
									</fo:table-cell>
									<fo:table-cell border-right="0.5pt solid #000000">
										<fo:block margin="3.5pt">
											<xsl:if test="fn:string-length(@xaxis) > 0">
												<fo:basic-link internal-destination="{@xaxis}" color="#000066">
													<xsl:value-of select="fn:replace(@xaxis,'_','_&#x200B;')" />
												</fo:basic-link>
											</xsl:if>
										</fo:block>
									</fo:table-cell>
									<fo:table-cell>
										<fo:block margin="3.5pt">
											<xsl:if test="fn:string-length(@xsignal) > 0">
												<fo:basic-link internal-destination="{@xsignal}" color="#000066">
													<xsl:value-of select="fn:replace(@xsignal,'_','_&#x200B;')" />
												</fo:basic-link>
											</xsl:if>
										</fo:block>
									</fo:table-cell>
								</fo:table-row>
								<fo:table-row border-bottom="0.5pt solid #000000" keep-together="always" keep-with-previous="always">
									<fo:table-cell border-right="0.5pt solid #000000">
										<fo:block margin="3.5pt">
											<xsl:if test="fn:string-length(@yaxis) > 0">
												<fo:basic-link internal-destination="{@yaxis}" color="#000066">
													<xsl:value-of select="fn:replace(@yaxis,'_','_&#x200B;')" />
												</fo:basic-link>
											</xsl:if>
										</fo:block>
									</fo:table-cell>
									<fo:table-cell>
										<fo:block margin="3.5pt">
											<xsl:if test="fn:string-length(@ysignal) > 0">
												<fo:basic-link internal-destination="{@ysignal}" color="#000066">
													<xsl:value-of select="fn:replace(@ysignal,'_','_&#x200B;')" />
												</fo:basic-link>
											</xsl:if>
										</fo:block>
									</fo:table-cell>
								</fo:table-row>
							</xsl:for-each-group>
						</fo:table-body>
					</fo:table>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$config/@emptydes"/>
				</xsl:otherwise>
			</xsl:choose>
		</fo:block>
	</xsl:template>
	
	<!-- Adds a table of bus definitions in the XSL-FO document. -->
	<xsl:template name="AddBusesTable">
		<xsl:param name="config"/>
		<fo:block>
			<xsl:if test="$config/@style">
				<saxon:call-template name="{$config/@style}"/>
			</xsl:if>
			<xsl:variable name="busset">
				<saxon:call-template name="{$config/@tpname}"/>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="fn:count($busset/syd:bus) > 0">
					<fo:table border="1pt solid #000000" table-layout="fixed" width="100%" font-size="{$dico-font-size-prop}">
						<fo:table-column column-width="25%" />
						<fo:table-column column-width="75%" />
						<fo:table-header font-weight="bold">
							<fo:table-row border-bottom="{if($showdatausage='true') then '0.5' else '1'}pt solid #000000" >
								<fo:table-cell number-rows-spanned="{if($showdatausage='true') then 2 else 1}" border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Name</fo:block>
								</fo:table-cell>
								<fo:table-cell>
									<fo:block margin="3.5pt">Signals</fo:block>
								</fo:table-cell>
							</fo:table-row>
							<xsl:if test="$showdatausage='true'">
								<fo:table-row border-bottom="1pt solid #000000" >
									<fo:table-cell>
										<fo:block margin="3.5pt">Bus Usage</fo:block>
									</fo:table-cell>
								</fo:table-row>
							</xsl:if>
						</fo:table-header>
						<fo:table-body>
							<xsl:variable name="root" select="fn:root()" />
							<xsl:for-each-group select="$busset/syd:bus" group-by="@out">
								<xsl:sort select="@out"/>
								<fo:table-row border-bottom="0.5pt solid #000000" keep-together="always">
									<fo:table-cell number-rows-spanned="{if($showdatausage='true') then 2 else 1}" border-right="0.5pt solid #000000">
										<fox:destination internal-destination="{@out}"/>
										<fo:block id="{@out}">
							                <fo:block margin="3.5pt">
							                	<xsl:value-of select="fn:replace(@out,'_','_&#x200B;')" />
							                </fo:block>
										</fo:block>
									</fo:table-cell>
									<fo:table-cell>
										<fo:block margin="3.5pt">
											<xsl:for-each select="syd:signal">
												<xsl:if test="fn:position() > 1">
													<xsl:text> | </xsl:text>
												</xsl:if>
												<fo:basic-link internal-destination="{@name}">
													<xsl:value-of select="@name" />
												</fo:basic-link>
											</xsl:for-each>
										</fo:block>
									</fo:table-cell>
								</fo:table-row>
								<xsl:if test="$showdatausage='true'">
									<fo:table-row border-bottom="0.5pt solid #000000" keep-with-previous="always">
										<fo:table-cell>
											<fo:block margin="3.5pt">
												<xsl:variable name="usage" select="syd:getDataUsage($root,@out)"/>
												<xsl:for-each select="$usage/usedby">
													<fo:block>
														<fo:basic-link internal-destination="{@id}" color="#000066">
															<xsl:value-of select="@id" />
														</fo:basic-link>
													</fo:block>
												</xsl:for-each>
											</fo:block>
										</fo:table-cell>
									</fo:table-row>
								</xsl:if>
							</xsl:for-each-group>
						</fo:table-body>
					</fo:table>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$config/@emptydes"/>
				</xsl:otherwise>
			</xsl:choose>
		</fo:block>
	</xsl:template>
	
	<!-- Adds a table of requirements in the XSL-FO document. -->
	<xsl:template name="AddRequirementsTable">
		<xsl:param name="config"/>
		<xsl:variable name="reqset">
			<xsl:choose>
				<xsl:when test="$config/@id">
					<xsl:sequence select="syd:getNodeByParentId(fn:root(),$config/@file,$config/@id,'syd:reqinfos')/syd:req"/>
				</xsl:when>
				<xsl:otherwise>
					<saxon:call-template name="{$config/@tpname}"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="doorsreqs" select="$reqset/syd:req[syd:isDoorsReq(text())]"/>
		<xsl:choose>
			<xsl:when test="fn:count($doorsreqs) > 0">
				<fo:block>
					<xsl:if test="$config/@style">
						<saxon:call-template name="{$config/@style}"/>
					</xsl:if>
					<fo:table border="1pt solid #000000" table-layout="fixed" width="100%" font-size="{$dico-font-size-prop}">
						<fo:table-column column-width="10%" />
						<fo:table-column column-width="15%" />
						<fo:table-column column-width="75%" />
						<fo:table-header font-weight="bold">
							<fo:table-row border-bottom="1pt solid #000000" >
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Design ID</fo:block>
								</fo:table-cell>
								<fo:table-cell border-right="0.5pt solid #000000">
									<fo:block margin="3.5pt">Requirement ID</fo:block>
								</fo:table-cell>
								<fo:table-cell>
									<fo:block margin="3.5pt">Description</fo:block>
								</fo:table-cell>
							</fo:table-row>
						</fo:table-header>
						<fo:table-body>
							<xsl:for-each select="$doorsreqs">
								<xsl:variable name="allreqs" select="syd:parseDoorsReq(text())"/>
								<xsl:variable name="reqs" select="$allreqs/doorsreq[@isreq = 'true']"/>
								<xsl:for-each select="$reqs">
									<fo:table-row border-bottom="0.5pt solid #000000" keep-together="always">
										<xsl:if test="fn:position() = 1">
											<fo:table-cell number-rows-spanned="{fn:count($reqs)}" border-right="0.5pt solid #000000">
												<xsl:variable name="surrogate" select="$allreqs/doorsreq[@isreq = 'false'][1]"/>
												<fo:block margin="3.5pt">
													<fo:basic-link external-destination="{fn:concat('url(',$doorsbaseurl,$surrogate/@id,'-',$surrogate/@doc,')')}">
														<xsl:value-of select="$surrogate/@id"/>
													</fo:basic-link>
												</fo:block>
											</fo:table-cell>
										</xsl:if>
										<xsl:variable name="link" select="fn:concat('url(',$doorsbaseurl,@id,'-',@doc,')')"/>
										<fo:table-cell border-right="0.5pt solid #000000">
											<fo:block margin="3.5pt">
												<fo:basic-link external-destination="{$link}">
													<xsl:value-of select="@id"/>
												</fo:basic-link>
											</fo:block>
										</fo:table-cell>
										<fo:table-cell>
											<fo:block margin="3.5pt">
												<fo:basic-link external-destination="{$link}">
													<xsl:value-of select="text()"/>
												</fo:basic-link>
											</fo:block>
										</fo:table-cell>
									</fo:table-row>
								</xsl:for-each>
							</xsl:for-each>
						</fo:table-body>
					</fo:table>
				</fo:block>
			</xsl:when>
			<xsl:otherwise>
				<xsl:if test="$config/@emptydes">
					<fo:block>
						<xsl:if test="$config/@style">
							<saxon:call-template name="{$config/@style}"/>
						</xsl:if>
						<xsl:value-of select="$config/@emptydes"/>
					</fo:block>
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- Assignable variable to store footnotes allready added to the document. -->
	<xsl:variable name="footnotes" select="''" saxon:assignable="yes"/>
	
	<!-- Adds a footnote. -->
	<!-- If a similar note was already defined in the document, the new note will reference the old one. -->
	<xsl:template name="AddFootNote">
		<xsl:param name="text" />
		<xsl:choose>
			<xsl:when test="fn:string-length($text) > 7">
				<xsl:variable name="footnodes" select="fn:tokenize($footnotes, '@')"/>
				<xsl:variable name="footcount" select="fn:count($footnodes)"/>
				<xsl:variable name="footnum" select="fn:index-of($footnodes,$text)"/>
				<xsl:choose>
					<xsl:when test="$footnum > 0">
						<fo:inline>
							<xsl:element name="fo:basic-link">
								<xsl:attribute name="internal-destination" select="fn:concat('*',$footnum)"/>
								*<fo:inline vertical-align="super" font-size="70%"><xsl:value-of select="$footnum"/></fo:inline>
							</xsl:element>
						</fo:inline>
					</xsl:when>
					<xsl:otherwise>
						<fo:footnote>
							<fo:inline>
								<xsl:element name="fo:basic-link">
									<xsl:attribute name="internal-destination" select="fn:concat('*',$footcount + 1)"/>
									*<fo:inline vertical-align="super" font-size="70%"><xsl:value-of select="$footcount + 1"/></fo:inline>
								</xsl:element>
							</fo:inline>
							<fo:footnote-body>
								<xsl:element name="fo:block">
									<xsl:attribute name="id" select="fn:concat('*',$footcount + 1)" />
									<fo:inline vertical-align="super" font-size="70%"><xsl:value-of select="$footcount + 1"/></fo:inline><xsl:value-of select="$text"/>
								</xsl:element>
							</fo:footnote-body>
						</fo:footnote>
						<saxon:assign name="footnotes">
							<xsl:choose>
								<xsl:when test="$footnotes = ''">
									<xsl:value-of select="$text"/>
								</xsl:when>
								<xsl:otherwise>
									<xsl:value-of select="fn:concat($footnotes,'@',$text)"/>
								</xsl:otherwise>
							</xsl:choose>
						</saxon:assign>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise><xsl:value-of select="$text"/></xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- Iterates over the dependent documents. -->
	<xsl:template name="IterateOverDeps">
		<xsl:param name="root"/>
		<xsl:param name="tpname"/>
		<xsl:for-each select="fn:tokenize($root/*/@mdldep,'\|')">
			<xsl:variable name="deproot" select="fn:document(fn:concat($xmluri,'/',.,'.xml'))" />
			<saxon:call-template name="{$tpname}">
				<xsl:with-param name="root" select="$deproot"/>
			</saxon:call-template>
		</xsl:for-each>
	</xsl:template>
	
	
	<!-- Computes the title for any system element. -->
	<xsl:function name="syd:getSystemTitle" as="xs:string">
		<xsl:param name="system" as="node()"/>
		<xsl:variable name="title">
			<xsl:choose>
				<xsl:when test="fn:name($system)='syd:modelref'">
					<xsl:choose>
						<xsl:when test="not(fn:exists($system/@system))">ModelRef: <xsl:value-of select="$system/@file"/></xsl:when>
						<xsl:otherwise>LinkedSystem: <xsl:value-of select="syd:substring-after-last($system/@system,'/')"/></xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:otherwise>
					<xsl:choose>
						<xsl:when test="fn:name($system)='syd:system'">System: </xsl:when>
						<xsl:when test="fn:name($system)='syd:chart'">Chart: </xsl:when>
						<xsl:when test="fn:name($system)='syd:state'">State: </xsl:when>
						<xsl:when test="fn:name($system)='syd:box'">Box: </xsl:when>
						<xsl:when test="fn:name($system)='syd:function'">Function: </xsl:when>
						<xsl:when test="fn:name($system)='syd:truthtable'">TruthTable: </xsl:when>
						<xsl:when test="fn:name($system)='syd:mfunction'">MFuntion: </xsl:when>
						<xsl:when test="fn:name($system)='syd:tablechart'">TableChart: </xsl:when>
						<xsl:when test="fn:name($system)='syd:tablestate'">TableState: </xsl:when>
						<xsl:otherwise>Unknown: </xsl:otherwise>
					</xsl:choose>
					<xsl:value-of select="syd:substring-after-last($system/@id,'/')"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:value-of select="$title"/>
	</xsl:function>
	
	<!-- Returns the value for a given key from a string with the format: "key1=val1;key2=val2;key3=val3" -->
	<xsl:function name="syd:get-map-value">
		<xsl:param name="pairs" as="xs:string"/>
		<xsl:param name="key" as="xs:string"/>
		<xsl:for-each select="fn:tokenize($pairs, ';')">
			<xsl:variable name="pair" select="." />
			<xsl:if test="fn:starts-with($pair,concat($key,'='))">
				<xsl:value-of select="fn:substring-after($pair,'=')"/>
			</xsl:if>
		</xsl:for-each>
	</xsl:function>
	
	<!-- Returns the substring after the last occurence of a given delimiter. -->
	<xsl:function name="syd:substring-after-last">
		<xsl:param name="string" as="xs:string"/>
		<xsl:param name="delimiter" as="xs:string"/>
		<xsl:choose>
			<xsl:when test="fn:contains($string, $delimiter)">
				<xsl:value-of select="syd:substring-after-last(fn:substring-after($string,$delimiter), $delimiter)"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$string" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	
	<!-- Assignable variable to keep track of the document titles numbering. -->
	<xsl:variable name="lasttitlenum" select="'0'" saxon:assignable="yes"/>
	
	<!-- Computes the number to give the a new title at the given level. -->
	<xsl:function name="syd:calcTitleNum" as="xs:string">
		<xsl:param name="level" as="xs:double"/>
		<xsl:variable name="lastidxs" select="fn:tokenize($lasttitlenum,'\.')"/>
		<xsl:variable name="lastlevel" select="fn:count($lastidxs)"/>
		<saxon:assign name="lasttitlenum">
			<xsl:choose>
				<xsl:when test="$level > $lastlevel">
					<xsl:value-of select="fn:concat($lasttitlenum,'.1')"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of>
						<xsl:if test="$level > 1">
							<xsl:for-each select="$lastidxs[$level > fn:position()]">
								<xsl:value-of select="."/>
								<xsl:text>.</xsl:text>
							</xsl:for-each>
						</xsl:if>
						<xsl:value-of select="fn:number($lastidxs[$level]) + 1"/>
					</xsl:value-of>
				</xsl:otherwise>
			</xsl:choose>
		</saxon:assign>	
		<xsl:value-of select="$lasttitlenum"/>
	</xsl:function>
	
	<!-- Gets the number at the given level for the current title. -->
	<xsl:function name="syd:getTitleNum" as="xs:string">
		<xsl:param name="level" as="xs:double"/>
		<xsl:variable name="lastidxs" select="fn:tokenize($lasttitlenum,'\.')"/>
		<xsl:value-of>
			<xsl:if test="$level > 1">
				<xsl:for-each select="$lastidxs[$level > fn:position()]">
					<xsl:value-of select="."/>
					<xsl:text>.</xsl:text>
				</xsl:for-each>
			</xsl:if>
			<xsl:value-of select="$lastidxs[$level]"/>
		</xsl:value-of>
	</xsl:function>
	
	<!-- Retrieves a node by its name and ID in the current document or in an external document. -->
	<xsl:function name="syd:getNodeById" as="node()">
		<xsl:param name="root" as="node()"/>
		<xsl:param name="file"/>
		<xsl:param name="id" as="xs:string"/>
		<xsl:param name="nodename" as="xs:string"/>
		<xsl:sequence select="if (fn:string-length($file) > 0)
			then fn:document(fn:concat($xmluri,'/',$file,'.xml'))//node()[fn:name() = $nodename and @id = $id]
			else $root//node()[fn:name() = $nodename and @id = $id]"/>
	</xsl:function>
	
	<!-- Retrieves a node by its name and parent ID in the current document or in an external document. -->
	<xsl:function name="syd:getNodeByParentId" as="node()">
		<xsl:param name="root" as="node()"/>
		<xsl:param name="file"/>
		<xsl:param name="id" as="xs:string"/>
		<xsl:param name="childname" as="xs:string"/>
		<xsl:sequence select="if (fn:string-length($file) > 0)
			then fn:document(fn:concat($xmluri,'/',$file,'.xml'))//node()[fn:name() = $childname and parent::*/@id = $id]
			else $root//node()[fn:name() = $childname and parent::*/@id = $id]"/>
	</xsl:function>
	
	<!-- Checks if the requirement text is coming form DOORS. -->
	<xsl:function name="syd:isDoorsReq" as="xs:boolean">
		<xsl:param name="text" as="xs:string"/>
		<xsl:sequence select="fn:contains($text,&quot;'linktype_rmi_doors'&quot;)"/>
	</xsl:function>
	
	<!-- Parses the DOORS requirement text. -->
	<xsl:function name="syd:parseDoorsReq" as="node()">
		<xsl:param name="text" as="xs:string"/>
		<xsl:variable name="res">
			<xsl:analyze-string select="$text" regex="'([^']*(''[^']*)*)'\s+'([^']*(''[^']*)*)'\s+'([^']*(''[^']*)*)'\s+'([^']*(''[^']*)*)'\s+'([^']*(''[^']*)*)'\s+'([^']*(''[^']*)*)'">
				<xsl:matching-substring>
					<doorsreq id="{fn:replace(regex-group(5),'#','')}" doc="{regex-group(3)}" isreq="{regex-group(7)}" tag="{regex-group(11)}"><xsl:value-of select="fn:replace(regex-group(9),'''''','''')"/></doorsreq>
				</xsl:matching-substring>
			</xsl:analyze-string>
		</xsl:variable>
		<xsl:sequence select="$res"/>
	</xsl:function>
	
	<!-- Gets the data usage. -->
	<xsl:function name="syd:getDataUsage" as="node()">
		<xsl:param name="root" as="node()"/>
		<xsl:param name="dataname" as="xs:string"/>
		<xsl:variable name="res">
			<xsl:for-each-group select="$root/descendant::svg:a[@xlink:href = fn:concat('#',$dataname)]/ancestor::node()[@id][1]" group-by="@id">
				<xsl:if test="not(fn:exists(ancestor::syd:system[syd:extradata/@security &gt; $security]))">
					<usedby id="{@id}" />
				</xsl:if>
			</xsl:for-each-group>
			<xsl:if test="$gendep='embed'">
				<xsl:for-each select="$root/descendant::syd:modelref">
					<xsl:variable name="refsysid" select="if(fn:exists(@system)) then @system else @file"/>
					<xsl:variable name="refsys" select="fn:document(fn:concat($xmluri,'/',@file,'.xml'))//node()[(fn:name() = 'syd:model' or fn:name() = 'syd:system') and @id = $refsysid]"/>
					<xsl:sequence select="syd:getDataUsage($refsys,$dataname)" />
				</xsl:for-each>
			</xsl:if>
		</xsl:variable>
		<xsl:sequence select="$res"/>
	</xsl:function>
	
	<!-- Extracts nodes with a given name from the hierachy of subsystems. -->
	<xsl:function name="syd:extractFromSystemHierarchy" as="node()">
		<xsl:param name="system" as="node()"/>
		<xsl:param name="nodename" as="xs:string"/>
		<xsl:variable name="res">
			<syd:system id="{$system/@id}">
				<xsl:for-each select="$system/node()[fn:name() = $nodename]">
					<xsl:copy-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="$system/syd:system[not(syd:extradata/@security) or syd:extradata/@security &lt;= $security]">
					<xsl:sequence select="syd:extractFromSystemHierarchy(.,$nodename)" />
				</xsl:for-each>
				<xsl:if test="$gendep='embed'">
					<xsl:for-each select="$system/syd:modelref">
						<xsl:variable name="refsysid" select="if(fn:exists(@system)) then @system else @file"/>
						<xsl:variable name="refsys" select="fn:document(fn:concat($xmluri,'/',@file,'.xml'))//node()[(fn:name() = 'syd:model' or fn:name() = 'syd:system') and @id = $refsysid]"/>
						<xsl:sequence select="syd:extractFromSystemHierarchy($refsys,$nodename)" />
					</xsl:for-each>
				</xsl:if>
			</syd:system>
		</xsl:variable>
		<xsl:sequence select="$res"/>
	</xsl:function>
	
</xsl:stylesheet>